---
description: 
globs: 
alwaysApply: false
---
### [코틀린 도메인 모델 ↔ JPO 매핑용 정적 팩토리 메서드 작성 커서 룰 프롬프트]

#### 목적
- 도메인 모델과 JPA Entity(Jpo) 간 매핑을 위한 **정적 메서드(fromJpo, toJpo 등)**를 일관성 있게 작성한다.
- 모든 매핑 로직은 도메인 모델의 companion object 내부에 위치시킨다.
- 매핑 대상이 되는 모든 필드는 null-safe, VO 변환, 컬렉션 변환, 중첩 객체 변환까지 책임진다.

#### 커서 룰

1. **companion object 내부에 아래와 같이 구현할 것**
    - `fun fromJpo(jpo: XxxJpo): Xxx`
    - `fun toJpo(domain: Xxx): XxxJpo`

2. **fromJpo 구현 시**
    - Jpo의 각 필드를 도메인 모델의 VO로 변환  
      (예: `UserName.from(jpo.name)`, `UserId.from(jpo.id)`, `PhoneNumber.from(jpo.phoneNo)` 등)
    - 중첩 객체(Jpo)도 반드시 해당 도메인 모델의 fromJpo로 변환  
      (예: `businessInfo = jpo.businessInfoJpo?.let { BusinessInfo.fromJpo(it) }`)
    - 컬렉션(List 등)은 mapNotNull로 변환  
      (예: `appliedConnections = jpo.appliedConnections.mapNotNull { BizConnection.fromJpo(it) }`)
    - null 가능성 있는 필드는 let, ?.let 등 null-safe하게 처리

3. **toJpo 구현 시**
    - 도메인 모델의 VO에서 원시값을 꺼내서 Jpo로 변환  
      (예: `name = domain.name.value`, `id = domain.id?.value`)
    - 중첩 객체(도메인 모델)도 반드시 toJpo로 변환  
      (예: `businessInfoJpo = domain.businessInfo?.let { BusinessInfo.toJpo(it) }`)
    - 컬렉션은 mapNotNull로 변환  
      (예: `appliedConnections = domain.appliedConnections.mapNotNull { BizConnection.toJpo(it) }`)
    - null 가능성 있는 필드는 let, ?.let 등 null-safe하게 처리

4. **비즈니스/불변성 검증은 도메인 모델 init 또는 VO 생성자에서만 책임진다.  
   매핑 메서드에서는 변환만 담당한다.**

5. **예시 코드**

```kotlin
companion object {
    fun fromJpo(jpo: UserJpo): User = User(
        id = jpo.id?.let { UserId.from(it) },
        name = UserName.from(jpo.name),
        belongsTo = jpo.belongsTo?.let { BelongsTo.from(it) },
        phoneNumber = jpo.userCredentialJpo?.phoneNo?.let { PhoneNumber.from(it) } ?: error("phoneNo is null"),
        password = jpo.userCredentialJpo?.password?.let { Password.from(it) } ?: error("password is null"),
        role = jpo.userCredentialJpo?.role ?: error("role is null"),
        createdAt = jpo.createdAt,
        updatedAt = jpo.updatedAt,
        deletedAt = jpo.deletedAt,
        credential = jpo.userCredentialJpo?.let { UserCredential.fromJpo(it) },
        appliedConnections = jpo.appliedConnections.mapNotNull { BizConnection.fromJpo(it) },
        // ... 이하 생략
    )

    fun toJpo(domain: User): UserJpo = UserJpo(
        id = domain.id?.value,
        name = domain.name.value,
        belongsTo = domain.belongsTo?.value,
        userCredentialJpo = domain.credential?.let { UserCredential.toJpo(it) },
        appliedConnections = domain.appliedConnections.mapNotNull { BizConnection.toJpo(it) },
        // ... 이하 생략
    )
}
```

6. **모든 도메인 모델, VO, Jpo에 대해 동일한 룰로 일관성 있게 적용**

#### 참고:  
- entity와 domain model간 혹은 command/result와 domain model간의 매핑 책임은 항상 도메인 모델(혹은 도메인 레이어 Factory)에 둔다.
- Jpo/Infra/Entity 쪽에서는 변환용 메서드만 최소한으로 제공,  
  비즈니스/검증/조립 책임은 도메인에만 둔다.
