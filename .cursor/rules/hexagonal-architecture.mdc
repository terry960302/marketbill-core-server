---
description: 헥사고날 아키텍처, DDD패턴, SOLID원칙 준수
globs: 
alwaysApply: true
---

1. **불필요한 중복 제거 + 핵심만 유지**
2. **폴더/역할/의존성/패턴/명명규칙의 구조화를 더 간단하고 단일화**
3. **작업자 입장에서 실제 ‘어디서부터 뭘 만들고 연결할지’에 바로 도움이 되도록**

---

## ✅ 최종 리팩토링된 MDC 규칙: Hexagonal + DDD 구조 가이드

> 📁 `flower` 또는 `user` 도메인을 참고하여 `cart`, `order` 등 새 도메인을 개발할 때 따라야 할 표준 규칙입니다.

---

### 1️⃣ 폴더 구조

```
{domain}/
├── adapter
│   ├── in/graphql/
│   │   ├── datafetcher/   # @DgsQuery/@DgsMutation
│   │   ├── dataloader/    # N+1 대응용 DataLoader
│   │   └── mapper/        # GraphQL DTO ↔ Command/Result 매핑
│   └── out/persistence/
│       ├── entity/        # JPA Entity (BaseJpo 상속)
│       ├── mapper/        # Jpo ↔ Domain 변환
│       └── repository/    # Repository 구현체 (Query/Crud 조합)
├── application
│   ├── command/           # 외부 요청 변환용 Command
│   ├── result/            # 도메인 결과를 외부로 반환
│   ├── port/outbound/     # 외부 연결용 인터페이스
│   ├── service/           # @Transactional, UseCase 조합
│   └── usecase/           # 핵심 비즈니스 로직
└── domain
    ├── model/             # 핵심 도메인 엔티티
    └── vo/                # 값 객체 (타입 안정성)
```
### 1-1. dgs-codegen 생성된 파일 위치
```
build/generated/sources/dgs-codegen/kr/co/marketbill/marketbillcoreserver/types
```
---

### 2️⃣ 계층별 역할

| 계층              | 설명                                         |
| --------------- | ------------------------------------------ |
| **domain**      | 도메인 모델 및 VO. 외부 의존 없음. 생성/검증/행위 포함         |
| **application** | Command/Result ↔ Domain 변환, 트랜잭션 관리, 포트 정의 |
| **adapter**     | 실제 API 요청 처리 및 영속화 구현. GraphQL 대응, DB 접근 등 |

---

### 3️⃣ 매핑 및 책임 규칙

* `Jpo ↔ Domain`: **Domain 내부** `fromJpo`, `toJpo` 또는 **Mapper 클래스**
* `Command/Result ↔ Domain`: **Domain 내부** 또는 `Mapper`
* `GraphQL DTO ↔ Command/Result`: `adapter/in/graphql/mapper`에서 처리

---

### 4️⃣ 명명 규칙

```kotlin
// Domain
data class Cart(...)                   // 핵심 도메인 객체
@JvmInline value class CartId(...)     // ID VO

// Application
data class CartSearchCommand(...)
data class CartSearchResult(...)
class CartService
class CartSearchUseCase
interface CartRepository               // Port

// Adapter
class CartFetcher(...)                 // @DgsComponent
class CartFieldFetcher(...)                 // @DgsComponent
object CartOutputMapper
data class CartRequest(...)
```

---

### 5️⃣ 의존성 방향 규칙

```
Adapter(in/out) → Application → Domain
```

❌ 다음은 절대 금지:

```
Domain → Application
Domain → Adapter
Application → Adapter
Adapter → 다른 Adapter
```

---

### 6️⃣ 서비스 & 유스케이스 작성

* `@Service`는 트랜잭션 경계 및 유스케이스 조합 역할만 수행
* 실제 비즈니스는 UseCase에서 처리
* Port를 통해 외부와 연결

---

### 7️⃣ Repository 구현 방식

```kotlin
@Repository
class CartRepositoryImpl(
    private val cartQueryRepository: CartQueryRepository, // 사용하는 경우만(복잡한 쿼리를 querydsl로만 가능한 경우)
    private val crudRepository: CartCrudRepository // 사용하는 경우만(간단한 JpaRepository crud 쿼리가 필요한경우)
) : CartRepository {
    override fun save(cart: Cart): Cart = ...
}
```

구성 요소:

* `CrudRepository`: 단순 CRUD
* `QueryRepository`: QueryDSL 등 복잡한 조건 대응
* JPO - Domain 매핑은 도메인모델에 있는 정적 메서드로 처리(절대 Mapper 사용금지)
---

### 8️⃣ JPA Entity 규칙

```kotlin
@Entity
@Table(name = "cart")
class CartJpo(
    @Id
    @GeneratedValue
    val id: Long? = null,
    ...
) : BaseJpo()
```

* `BaseJpo` 상속 필수
* `equals()/hashCode()` 오버라이드(필수)
* 관계 매핑 시 **LAZY 기본**, `orphanRemoval = true` 적용 여부 확인

---

### 9️⃣ GraphQL Fetcher & DataLoader

* 모든 진입점은 `Fetcher`에 `@DgsComponent`로 정의
* 응답 타입은 반드시 **`types` 패키지의 DGS Codegen 타입 사용**(경로 : {root}/build/generated/sources/dgs-codegen/kr/co/marketbill/marketbillcoreserver/types)
* N+1 이슈 예상 시 `DataLoader` 구현

#### 9-1. ❗GraphQL은 참고만, 절대 수정하지 말 것
resources/schema/{도메인명}.graphql 은 고정된 계약(Contract)

새 필드/쿼리가 필요하면 팀에 요청

#### 9-2. ✅ DataFetcher 작성 원칙
| 항목    | 규칙                                                       |
| ----- | -------------------------------------------------------- |
| 위치    | `adapter/in/graphql/datafetcher/`                        |
| 어노테이션 | `@DgsComponent`, `@DgsQuery`, `@DgsMutation`, `@DgsData`(내부에 들어가는 parentType, field는 DgsConstant(build/generated/sources/dgs-codegen/kr/co/marketbill/marketbillcoreserver/DgsConstants.kt)를 참고) |
| 책임    | Service 호출 → Command 전달 → Result 반환                      |
| 반환    | 반드시 `types` 패키지의 Codegen 타입 사용                           |


✅ DataLoader 작성 원칙
| 항목    | 규칙                                  |
| ----- | ----------------------------------- |
| 위치    | `adapter/in/graphql/dataloader/`    |
| 어노테이션 | `@DgsDataLoader`                    |
| 로딩 방식 | `MappedBatchLoaderWithContext` 구현   |
| 용도    | GraphQL의 N+1 문제 해결. 연관관계가 존재할 때만 사용 |
| 인자 전달    | DataFetcher에서 dataloader.load(ids, {context객체})로 전달하고 dataloader에서 environment.keyContexts로 받음 |



---

### 🔟 테스트 구조 (src/test)

```
{domain}/
├── domain/
├── application/
└── adapter/
```

테스트 명명:

```kotlin
class CartServiceTest
class CartSearchUseCaseTest
class CartFetcherTest
```

---

### ✅ 생성 체크리스트 요약

| 계층              | 체크리스트                                                   |
| --------------- | ------------------------------------------------------- |
| **domain**      | `data class`, VO는 `@JvmInline`, 유효성 검사 포함               |
| **application** | `fromGraphql`/`from()` 팩토리 메서드, UseCase는 로직만            |
| **adapter**     | DTO → Command → Service → Result → DTO 구조 준수            |
| **repository**  | Query + Crud + Mapper 조합, Mapper는 `@Component`          |
| **graphql**     | DTO ↔ Command/Result 매핑은 `OutputMapper`, 타입은 `types` 사용 |

---

### 11. 🎯 필수 개발 순서
작업은 반드시 다음 순서로 진행해야 합니다:

1. GraphQL 스키마 확인

- resources/schema/{도메인명}.graphql을 열람

- 스키마는 절대 수정하지 말고, 해당 쿼리/필드 명세를 기준으로 구현

2. 도메인 정의 (domain/model, domain/vo)

- GraphQL에서 사용되는 Entity에 해당하는 도메인 모델 생성

- VO 정의 및 유효성 검사 포함

3. Command/Result 정의 (application/command, result)

- GraphQL Input → Command

- Domain → Result → Output으로 흐름 설계

4. UseCase 구현 (application/usecase)

- 비즈니스 로직 구성

- 외부 시스템 연결은 Port를 통해 접근

5. Port 인터페이스 정의 (application/port/outbound)

6. Service 구현 (application/service)

- UseCase 조합, 트랜잭션 관리

- 도메인 모델 메서드를 기반으로 설계 (역참조 금지)

7. Persistence 구현 (adapter/out/persistence)

- Repository, Entity(Jpo), Mapper

8. GraphQL Adapter 구현 (adapter/in/graphql)

- datafetcher/, dataloader/, mapper/ 작성

- 반드시 schema/{도메인명}.graphql 기반으로만 구현

#### 11-1. 🚫 잘못된 작업 방식 예시
❌ GraphQL 스키마를 먼저 수정하고 Fetcher를 구현

❌ domain/model 없이 먼저 Service 작성

❌ VO나 Command가 없는 상태에서 UseCase부터 작성

❌ Mapper 없이 DTO ↔ Entity 직접 변환

→ 위 방식은 전부 컴파일 오류 / 구조 오염 / 중복 로직을 유발합니다.

#### 11-2. ✅ 올바른 흐름 예시
GraphQL에 getOrders(filter: OrderFilterInput): OrdersOutput이 있다면 
- Order.kt, OrderId.kt 등의 도메인 작성
- OrderSearchCommand, OrderSearchResult 작성
- OrderSearchUseCase에서 조건 조회 로직 구현
- OrderService에서 트랜잭션 제어 및 유스케이스 호출
- OrderFetcher에서 Input → Command → Result → Output 변환(여기서 N+1문제가 있을 거 같으면 Dataloader, FieldFetcher 추가 구현)
- OrderOutputMapper에서 DGS 타입으로 최종 변환